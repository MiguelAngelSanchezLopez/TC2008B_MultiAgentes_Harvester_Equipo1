# -*- coding: utf-8 -*-
"""Granja Con Harvesters.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nfe1ah-kW4ENGd8iw6CqnfqLALSJG3eQ
"""

!pip install agentpy

def draw_tile(graph, id, style):
    r = " . "
    if 'number' in style and id in style['number']: r = " %-2d" % style['number'][id]
    if 'point_to' in style and style['point_to'].get(id, None) is not None:
        (x1, y1) = id
        (x2, y2) = style['point_to'][id]
        if x2 == x1 + 1: r = " > "
        if x2 == x1 - 1: r = " < "
        if y2 == y1 + 1: r = " v "
        if y2 == y1 - 1: r = " ^ "
    if 'path' in style and id in style['path']:   r = " @ "
    if 'start' in style and id == style['start']: r = " A "
    if 'goal' in style and id == style['goal']:   r = " G "
    if id in graph.walls: r = "###"
    return r

def draw_grid(graph, **style):
    print("___" * graph.width)
    for y in range(graph.height):
        for x in range(graph.width):
            print("%s" % draw_tile(graph, (x, y), style), end="")
        print()
    print("~~~" * graph.width)

from typing import Protocol, Iterator, Tuple, TypeVar, Optional, List, Dict
from __future__ import annotations

T = TypeVar('T')

Location = TypeVar('Location')
class Graph(Protocol):
    def neighbors(self, id: Location) -> list[Location]: pass
GridLocation = Tuple[int, int]

class SquareGrid:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.walls: List[GridLocation] = []

    def in_bounds(self, id: GridLocation) -> bool:
        (x, y) = id
        return 0 <= x < self.width and 0 <= y < self.height

    def passable(self, id: GridLocation) -> bool:
        return id not in self.walls

    def neighbors(self, id: GridLocation) -> Iterator[GridLocation]:
        (x, y) = id
        neighbors = [(x+1, y), (x-1, y), (x, y-1), (x, y+1)] # E W N S
        if (x + y) % 2 == 0: neighbors.reverse() # S N W E
        results = filter(self.in_bounds, neighbors)
        results = filter(self.passable, results)
        return results

class WeightedGraph(Graph):
    def cost(self, from_id: Location, to_id: Location) -> float: pass

class GridWithWeights(SquareGrid):
    def __init__(self, width: int, height: int):
        super().__init__(width, height)
        self.weights: dict[GridLocation, float] = {}

    def cost(self, from_node: GridLocation, to_node: GridLocation) -> float:
        return self.weights.get(to_node, 1)

import heapq

class PriorityQueue:
    def __init__(self):
        self.elements: list[tuple[float, T]] = []

    def empty(self) -> bool:
        return not self.elements

    def put(self, item: T, priority: float):
        heapq.heappush(self.elements, (priority, item))

    def get(self) -> T:
        return heapq.heappop(self.elements)[1]

def heuristic(a: GridLocation, b: GridLocation) -> float:
    (x1, y1) = a
    (x2, y2) = b
    return abs(x1 - x2) + abs(y1 - y2)

def a_star_search(graph: WeightedGraph, start: Location, goal: Location):
    frontier = PriorityQueue()
    frontier.put(start, 0)
    came_from: dict[Location, Optional[Location]] = {}
    cost_so_far: dict[Location, float] = {}
    came_from[start] = None
    cost_so_far[start] = 0

    while not frontier.empty():
        current: Location = frontier.get()

        if current == goal:
            break

        for next in graph.neighbors(current):
            new_cost = cost_so_far[current] + graph.cost(current, next)
            if next not in cost_so_far or new_cost < cost_so_far[next]:
                cost_so_far[next] = new_cost
                priority = new_cost + heuristic(next, goal)
                frontier.put(next, priority)
                came_from[next] = current

    return came_from, cost_so_far

def reconstruct_path(came_from: dict[Location, Location],
                     start: Location, goal: Location) -> list[Location]:

    current: Location = goal
    path: list[Location] = []
    if goal not in came_from: # no path was found
        return []
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start) # optional
    path.reverse() # optional
    return path

import agentpy as ap
import matplotlib.pyplot as plt
import seaborn as sns
import IPython
from collections import deque
import random

# Crear el grid para A* con los valores de los agentes
def create_a_star_grid(model):
    size = model.p.size
    grid_costs = [[0] * size for _ in range(size)]

    # Extre los valores de los agentes del grid
    attr_grid = model.campo.attr_grid('condition')

    for y in range(size):
        for x in range(size):
            value = attr_grid[y][x]
            if value == 0: # si es el tractor
                grid_costs[y][x] = 300  # Se le da un costo de 50 a la celda
            elif value == 1: # Si esta unharvested
                grid_costs[y][x] = 100  # Se le da un costo de 2
            elif value == 2: # si ya esta harvested
                grid_costs[y][x] = 5  # El costo es de 10
            elif value == 3: # Y si es un obstaculo
                grid_costs[y][x] = 10000  # Se le da un costo de 1000
            elif value == 4: # Warehouse
                grid_costs[y][x] = 25
            elif value == 5: # Harvester
                grid_costs[y][x] = 300
            else:
                grid_costs[y][x] = 5

    # Debug: print the grid costs
    #print("grid_costs:")
    #for row in grid_costs:
    #    print(row)

    # Regresa el grid que se usara para el A*
    return grid_costs

# Crea el weighted grid
def create_weighted_grid(grid_costs):
    width = len(grid_costs[0])
    height = len(grid_costs)

    # Se crea un grid para el A* (vacio)
    weighted_grid = GridWithWeights(width, height)
    weighted_grid.walls = []

    # Por el grid de pesos que se creo en la funcion anterior
    # se le agrega al grid que se utiliza en el A*
    for y in range(height):
        for x in range(width):
            cost = grid_costs[y][x]
            if cost != 1000:  # Only add weights for non-obstacle cells
                weighted_grid.weights[(y, x)] = cost
            else:
                weighted_grid.walls.append((y, x))

    # Debug: print the weighted grid details
    #print("weighted_grid.weights:")
    #for key, value in weighted_grid.weights.items():
    #    print(f"{key}: {value}")

    #print("weighted_grid.walls:")
    #print(weighted_grid.walls)

    # Regresa el grid con pesos
    return weighted_grid

class Harvest(ap.Agent):
    def setup(self):
        self.condition = 1  # 0: Tractor, 1: Unharvested, 2: harvested

    def collect(self):
        if self.condition == 1:
            self.condition = 2  # Marca la cosecha como recolectada
            model.crops_left -= 1
            model.crops_harvested += 1
            return 1  # Retorna 1 para indicar que una cosecha fue recolectada
        return 0  # Retorna 0 si ya estaba recolectada

class Obstacle(ap.Agent):
    def setup(self):
        self.condition = 3  # 3: Obstáculo

class Warehouse(ap.Agent):
    def setup(self):
        self.condition = 4 # 4 : Warehouse

class Harvester(ap.Agent):
    def setup(self):
        self.condition = 5 # 5 : Harvester
        self.campo = self.model.campo
        self.path = deque()
        self.to_truck = True

    def A_Star(self, start: GridLocation, goal) -> Optional[GridLocation]:
        grid_costs = create_a_star_grid(self.model)
        weighted_grid = create_weighted_grid(grid_costs)

        came_from, _ = a_star_search(weighted_grid, start, goal)
        path = reconstruct_path(came_from, start, goal)

        # DEBUG !!
        #print("Step", self.model.t)
        #print("Start pos", start)
        #print("Goal", goal)
        #print("Path", path)
        #draw_grid(weighted_grid, path=path)

        return path

    def find_closest_tractor(self):
        min_distance = float('inf')
        closest_tractor = None
        for tractor in model.tractores:
            if not tractor.isMoving and not tractor.harvesterAssigned:
                distance = self.calculate_distance(model.campo.positions[self], model.campo.positions[tractor])
                if distance < min_distance:
                    min_distance = distance
                    closest_tractor = tractor
        if closest_tractor is not None:
            closest_tractor.harvesterAssigned = True
        return model.campo.positions[closest_tractor] if closest_tractor else None

    def find_closest_warehouse(self):
        min_distance = float('inf')
        closest_warehouse = None
        for warehouse in model.warehouses:
            distance = self.calculate_distance(model.campo.positions[self], model.campo.positions[warehouse])
            if distance < min_distance:
                min_distance = distance
                closest_warehouse = warehouse
        return model.campo.positions[closest_warehouse] if closest_warehouse else None

    def calculate_distance(self, pos1, pos2):
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

    def is_valid_position(self, pos):
      # Verifica si la posición está dentro de los límites del campo.
      # Comprueba si la coordenada x (pos[0]) y la coordenada y (pos[1]) están dentro del rango permitido.
      if 0 <= pos[0] < self.model.p.size and 0 <= pos[1] < self.model.p.size:

          # Obtiene todos los agentes en la posición especificada.
          agents_in_pos = list(self.campo.agents[pos])

          # Comprueba si no hay ningún obstáculo en la posición.
          # Recorre todos los agentes en la posición y verifica si alguno es una instancia de Obstacle.
          if not any(isinstance(agent, Obstacle) or isinstance(agent, Tractor) for agent in agents_in_pos):
              # Si no hay obstáculos, la posición es válida.
              return True

      # Si la posición está fuera de los límites o hay un obstáculo, no es válida.
      return False

    def move(self):
        if self.path:
            next_pos = self.path[0] #Get next pos in path
            agents_in_pos = list(self.campo.agents[next_pos]) #get agents in next pos (can be overlapping)
            if not any(isinstance(agent, Obstacle) for agent in agents_in_pos): #if they're not obstacles
                for agent in agents_in_pos:
                    if isinstance(agent, Tractor): # if next pos is a tractor
                        if self.to_truck: # and was originally going to one
                            if not agent.isMoving:
                              agent.capacity = self.p['capacity'] # resets tractor capacity
                              agent.isMoving = True
                              agent.harvesterAssigned = False
                              self.to_truck = False # and is now moving to warehouse
                              # if it wasn't going to a tractor and found one, it needs to recalculate its route to
                              # not clash; if it was going to one, then it has fulfilled its objective
                              self.path.clear()
                        break
                    elif isinstance(agent, Warehouse): # if next pos is a warehouse
                        # then it can now go to a truck. If it was going to a truck originally, it doesn't
                        # matter
                        self.to_truck = True
            # if the path didn't get cleared
            if self.path:
                self.path.popleft()
                self.campo.move_to(self, next_pos)
        else:

            current_pos = self.campo.positions[self]

            if self.to_truck:
                tractor = self.find_closest_tractor()
                if tractor is not None:
                    self.path = deque(self.A_Star(current_pos, tractor))
            else:
                warehouse = self.find_closest_warehouse()
                self.path = deque(self.A_Star(current_pos, warehouse))

class Tractor(ap.Agent):
    def setup(self):
        self.condition = 0
        self.capacity = self.p['capacity']  # Initialize with the given capacity parameter
        self.initial_capacity = self.capacity  # Store the initial capacity
        self.campo = self.model.campo
        self.warehouse_path = deque()
        self.isMoving = True
        self.harvesterAssigned = False

    def move_and_collect(self):
        # Obtiene la posición actual del tractor
        current_pos = self.campo.positions[self]
        if self.capacity > 0:  # Si el tractor aún tiene capacidad
            # Encuentra la cosecha más cercana, evitando obstáculos
            target_pos = self.find_closest_harvest(current_pos)
            path = self.bfs(current_pos, target_pos)
            if len(path) > 1:
                # Mueve el tractor a la siguiente posición en el camino
                next_pos = path[1]
            else:
                # Si ya estamos en el objetivo, no se mueve
                next_pos = current_pos

            # Verifica si la siguiente posición es válida
            if self.is_valid_position(next_pos):
                # Obtiene todos los agentes en la próxima posición
                agents_in_pos = list(self.campo.agents[next_pos])

                # Itera sobre los agentes en la próxima posición
                for agent in agents_in_pos:
                    # Si encuentra una cosecha y el tractor aún tiene capacidad
                    if isinstance(agent, Harvest) and self.capacity > 0:
                        # Recolecta la cosecha y reduce la capacidad del tractor
                        self.capacity -= agent.collect()
                        if self.capacity == 0:
                            self.isMoving = False
                        break

                # Mueve el tractor a la siguiente posición
                self.campo.move_to(self, next_pos)

    def is_valid_position(self, pos):
      # Verifica si la posición está dentro de los límites del campo.
      # Comprueba si la coordenada x (pos[0]) y la coordenada y (pos[1]) están dentro del rango permitido.
      if 0 <= pos[0] < self.model.p.size and 0 <= pos[1] < self.model.p.size:

          # Obtiene todos los agentes en la posición especificada.
          agents_in_pos = list(self.campo.agents[pos])

          # Comprueba si no hay ningún obstáculo en la posición.
          # Recorre todos los agentes en la posición y verifica si alguno es una instancia de Obstacle.
          if not any(isinstance(agent, Obstacle) or isinstance(agent, Tractor) or isinstance(agent, Warehouse) or isinstance(agent, Harvester) for agent in agents_in_pos):
              # Si no hay obstáculos, la posición es válida.
              return True

      # Si la posición está fuera de los límites o hay un obstáculo, no es válida.
      return False


    def find_closest_harvest(self, start):
      # Inicia una cola (queue) con la posición inicial (start)
      queue = deque([start])

      # Crea un conjunto (set) para rastrear las posiciones visitadas
      visited = set()

      # Marca la posición inicial como visitada
      visited.add(start)

      # Comienza a recorrer la cola mientras no esté vacía
      while queue:
          # Extrae la primera posición de la cola
          pos = queue.popleft()

          # Verifica si la posición actual contiene algún agente
          if pos in self.campo.positions.values():
              # Obtiene todos los agentes en la posición actual
              agents_in_pos = list(self.campo.agents[pos])

              # Itera sobre los agentes en la posición
              for agent in agents_in_pos:
                  # Si el agente es una cosecha (Harvest) y su condición es 1 (disponible para recolección)
                  if isinstance(agent, Harvest) and agent.condition == 1:
                      # Devuelve la posición de esta cosecha
                      return pos

          # Si no se encuentra una cosecha en la posición actual, obtiene las posiciones vecinas
          neighbors = self.get_neighbors(pos)

          # Itera sobre las posiciones vecinas
          for neighbor in neighbors:
              # Si la posición vecina no ha sido visitada, la marca como visitada
              if neighbor not in visited:
                  visited.add(neighbor)
                  # Añade la posición vecina a la cola para procesarla después
                  queue.append(neighbor)

      # Si no se encuentra ninguna cosecha válida, devuelve None
      return None


    def bfs(self, start, goal):
      # Inicia una cola con un solo camino que comienza en la posición inicial (start)
      queue = deque([[start]])

      # Crea un conjunto para rastrear las posiciones visitadas
      visited = set()

      # Marca la posición inicial como visitada
      visited.add(start)

      # Comienza a recorrer la cola mientras no esté vacía
      while queue:
          # Extrae el primer camino de la cola
          path = queue.popleft()

          # Obtiene la última posición en el camino actual
          current = path[-1]

          # Si la posición actual es el objetivo, devuelve el camino que llevó hasta allí
          if current == goal:
              return path

          # Recorre todas las posiciones vecinas de la posición actual
          for neighbor in self.get_neighbors(current):
              # Si la posición vecina no ha sido visitada, procede
              if neighbor not in visited:
                  # Marca la posición vecina como visitada
                  visited.add(neighbor)

                  # Crea un nuevo camino que incluye esta posición vecina
                  new_path = list(path)
                  new_path.append(neighbor)

                  # Añade el nuevo camino a la cola para explorarlo más tarde
                  queue.append(new_path)

      # Si no se encuentra un camino al objetivo, devuelve un camino que solo contiene la posición inicial
      return [start]


    def get_neighbors(self, pos):
      # Crea una lista vacía para almacenar los vecinos válidos
      neighbors = []

      # Define las direcciones posibles de movimiento: derecha, izquierda, abajo, arriba
      directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

      # Recorre cada dirección posible
      for direction in directions:
          # Calcula la nueva posición vecina sumando la dirección a la posición actual
          neighbor = (pos[0] + direction[0], pos[1] + direction[1])

          # Verifica si la nueva posición está dentro de los límites del campo
          if 0 <= neighbor[0] < self.model.p.size and 0 <= neighbor[1] < self.model.p.size:
              # Obtiene todos los agentes en la nueva posición vecina
              agents_in_pos = list(self.campo.agents[neighbor])

              # Comprueba si la nueva posición no contiene un obstáculo
              if not any(isinstance(agent, Obstacle) or isinstance(agent, Warehouse) for agent in agents_in_pos):
                  # Si no hay obstáculo, añade la posición vecina a la lista de vecinos válidos
                  neighbors.append(neighbor)

      # Devuelve la lista de vecinos válidos
      return neighbors

class HarvestModel(ap.Model):
    def setup(self):
        # Initialize the grid
        self.campo = ap.Grid(self, [self.p.size] * 2, track_empty=True)
        self.agents = ap.AgentList(self)

        # Create and place warehouses
        self.warehouses = ap.AgentList(self, self.p['warehouses'], Warehouse)
        self.campo.add_agents(self.warehouses, random=True, empty=True)

        # Create and place tractors
        self.tractores = ap.AgentList(self, self.p['tractores'], Tractor)
        self.campo.add_agents(self.tractores, random=True, empty=True)

        # Create harvesters list
        self.harvesters = ap.AgentList(self, self.p['tractores'], Harvester)  # Assuming number of harvesters equals number of tractors

        # Assign positions to harvesters
        self.assign_harvester_positions()

        # Place harvesters
        self.campo.add_agents(self.harvesters, positions=self.harvester_positions)

        # Calculate the number of available cells for obstacles and crops
        total_cells = self.p.size ** 2
        available_cells = total_cells - len(self.tractores) - len(self.warehouses) - len(self.harvesters)

        # Create obstacles and crops if there are available cells
        max_obstacles = min(self.p['obstacles'], available_cells)
        max_crops = min(int(self.p['harvest_density'] * available_cells), available_cells - max_obstacles)

        if max_obstacles > 0:
            obstacles = ap.AgentList(self, max_obstacles, Obstacle)
            self.campo.add_agents(obstacles, random=True, empty=True)

        if max_crops > 0:
            crops = ap.AgentList(self, max_crops, Harvest)
            self.campo.add_agents(crops, random=True, empty=True)

        # Initialize crop counters
        self.crops_left = max_crops
        self.crops_harvested = 0
        self.crops_collected = []

    def get_adjacent_positions(self, position):
        x, y = position
        adj_positions = [
            (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)
        ]
        return [p for p in adj_positions if 0 <= p[0] < self.p.size and 0 <= p[1] < self.p.size]

    def assign_harvester_positions(self):
        self.harvester_positions = []
        for tractor in self.tractores:
            tractor_pos = self.campo.positions[tractor]
            adjacent_positions = self.get_adjacent_positions(tractor_pos)
            chosen_position = random.choice(adjacent_positions)
            self.harvester_positions.append(chosen_position)

        if len(self.harvester_positions) < len(self.harvesters):
            print("Not all harvesters could be assigned valid positions.")
            # Optionally handle the case where not all harvesters could be placed

    def step(self):
        if self.crops_left > 0:
            for tractor in self.tractores:
                if tractor.isMoving:
                    tractor.move_and_collect()

            for harvester in self.harvesters:
                harvester.move()
        else:
            self.stop()

def animation_plot(model, ax):
    attr_grid = model.campo.attr_grid('condition')

    # Definir los colores para los diferentes agentes
    color_dict = {
        0: '#008000',  # Tractor - Dark Green
        1: '#fff789',  # Unharvested - Yellow
        2: '#9B870C',  # Harvested - Gold
        3: '#1E2E38',  # Obstacle - Black
        4: '#903b1c',  # Warehouse - Red
        5: '#795695',  # Harvester - purple
        None: '#d5e5d5'  # Empty Space - Light Gray
    }

    # Plot el grid
    ap.gridplot(attr_grid, ax=ax, color_dict=color_dict, convert=True)

    # Superposición de las capacidades del tractor
    for tractor in model.tractores:
        pos = model.campo.positions[tractor]
        ax.text(pos[1], pos[0], f'Cap: {tractor.capacity}',
                ha='center', va='center', color='white', fontsize=8,
                bbox=dict(facecolor='black', alpha=0.5, edgecolor='none'))

    for harvester in model.harvesters:
        pos = model.campo.positions[harvester]
        ax.text(pos[1], pos[0], f'Harvester',
                ha='center', va='center', color='white', fontsize=8,
                bbox=dict(facecolor='black', alpha=0.5, edgecolor='none'))

    # Agregar título con el paso de tiempo actual y los cultivos restantes
    ax.set_title(f"Simulation of a Harvest\n"
                 f"Time-step: {model.t}, Crops left: "
                 f"{model.crops_left}")

parameters = {
    'steps': 400,
    'size': 25,
    'harvest_density': 1,
    'obstacles': 25,
    'tractores' : 3, # el numero de harvesters es igual
    'warehouses' : 3,
    'capacity' : 50,
}

# Configurar la animación
fig, ax = plt.subplots(figsize=(8, 8))
model = HarvestModel(parameters)
animation = ap.animate(model, fig, ax, animation_plot)
IPython.display.HTML(animation.to_jshtml(fps=10))